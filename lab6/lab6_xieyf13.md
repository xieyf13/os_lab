## 练习0：填写已有实验

## 练习1：用 Round Robin 调度算法（不需要编码）

- 请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描ucore的调度执行过程

`RR_enqueue`函数负责将一个进程加入到调度队列的末尾, 并初始化时间片长度, 等待被执行. 

`RR_dequeue`函数负责将指定的进程从调度队列中删去(因此严格的说这个操作是delete, 而不是dequeue)

`RR_init`初始化调度队列. 

`RR_proc_tick`每次时钟中断都会调用, 将当前进程的时间片剩余减一, 如果已经为零, 那么将该进程置于可被调度状态. 

`RR_pick_next`将队列中最靠前的进程选出并返回. 

就lab6而言, ucore中调度执行包含两部分, 一个部分是在每次时钟中断发生时, `RR_proc_tick`都会被调用, `current`进程的时间片剩余时间被修改, 或是进入可被调度状态. 

另一部分是`init`函数中最后的`cpu_idle`函数, 这个函数会不停地判断当前进程是否需要被调度, 如果需要被调度, 就调用`schdule`函数, `schdule`函数会检查当前进程是否仍然处于可运行的状态, 如果是, 那么, 就将当前进程重新加入调度队列当中, 之后, 从调度队列中选取下一个被执行的进程, 并将其从调度队列中删除, 执行该进程. 

- 如何设计实现”多级反馈队列调度算法“

多级反馈队列调度算法可以借助时间片轮转算法完成, 思路如下:

将ucore中现有的一个`run_list`改为一个`run_lists[]`, 而对于不同的调度队列, 设置不同的最大时间片时间, 例如100, 150, 200, 250, 300..., 几个队列的优先级也逐渐递减. 在进行enqueue时, 根据进程优先级, 将进程插入到特定的调度队列当中, 对于同一个调度队列中的进程, 采取时间片轮转算法进行调度, 选择下一个进程时, 优先从高优先级队列里进行选择. 

## 练习2: 实现 Stride Scheduling 调度算法（需要编码）

Stride Schedule调度算法的大致思想, 是为每个进程维持一个"路程", 每次选择进程, 就将行走"路程"最短那个为下一个. 而每个进程的"路程", 根据以下的方法进行确定: 先确定一个大常数, 然后每次进程被选择时, 路程就加上这个大常数除以优先级的数值, 这样运行足够长的时间, 就可以保证每个进程运行的时间, 大致和优先级的倒数成比例. 

在实际实现的过程中, 会有"路程"溢出的问题, 在解决这个问题之前, 需要先确定一个结论, 即在一次调度之后, 任何进程之间的"路程"差距不会多于一个之前设定的大常数, 因为多于一个大常数的话(我们可以假设是"路程"最短进程和"路程"最长之间的差距), 就意味着这个调度之后少于另外某进程多于一个大常数的进程, 在调度之前也一定小于某进程, 但它却没有得到调度. 这与该算法矛盾. 

通过这个结论, 就可以判断两个进程之间的前后差距, 即"路程"相差不多于一个大常数, 而如果大常数选为0x7FFFFFFF, 就可以利用有符号数的比较, 确定是否超过大常数. 

在细节上, Stride Schedule调度算法可以完全沿用时间片轮转算法中函数的语义, 但不采用调度队列而采用调度堆. 
 
